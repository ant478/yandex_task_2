Лабиринт
========

Карта лабиринта задана матрицей `N×M`, в которой `0` обозначает пустую клетку, а `−1` обозначает стену. Вы стартуете в точке с координатами `(x=1; y=0)` и на каждом ходу можете перейти на пустую соседнюю точку, расположенную справа, слева, сверху или снизу. Нужно реализовать функцию `solution`, прокладывающую маршрут до выхода.

Выходов может быть несколько. Точки выхода всегда удовлетворяют условию `y=M`.

Дополнительная задача: сделать пошаговую визуализацию выполнения алгоритма.

Описание алгоритма:

 Алгоритм иммитирует передвижение в лабиринте человека с завязанными глазами (далее - игрока). Игрок может двигаться вниз, вверх, влево или вправо на 1 клетку, может определять есть ли на соседней клетке стена (т.е. передвигается на ощупь), и может определить нашел ли он выход. (в целях контроля ошибок игроку были добавлены возможности чувствовать что он находится за краем лабиринта, а также что его в самом начале телопортировали в стену). Он не знает расположения выхода и стен. Человек, передвигающийся по лабиринту вслепую, скорее всего будет двигаться в одном направлении, пока не наткнется на стену. Затем он на ошупь определит в каком направлении можно продолжать движение и пойдет в ту сторону до следующей стены и так далее. В случае если он зайдет в тупик, он вернется к последней развилке, и пойдет в ту сторону, в какую ещё не ходил. Если же и там он найдет тупик, он снова вернется к последней развилке. Если он испробовал все направления движения от последней развилки - он вернется к предпоследней и пойдет в ту сторону в какую ещё не ходил, и так далее. Таким образом, обход лабиринта можно представить как рекурсивный алгоритм вида:

   действие осмотреться() {
       если (выход_найден) {
           выйти_из_лабиринта();
       } иначе если (можно_двигаться_в_прежнем направлении) {
           сделать шаг в прежнем направлении();
           осмотреться();
       } иначе если (можно_двигаться_вправо) {
           сделать_шаг_вправо();
           осмотреться();
       } иначе если (можно_двигаться_вниз) {
           сделать_шаг_вниз();
           осмотреться();
       } иначе если (можно_двигаться_влево) {
           сделать_шаг_влево();
           осмотреться();
       } иначе если (можно_двигаться_вверх) {
           сделать_шаг_вверх();
           осмотреться();
       } иначе если (не_в_исходной_точке){
           сделать_шаг_назад();
       } иначе {
           остаться_в_лабиринте навсегда();
       }
   }
   // под "можно" подразумевается что на соседней клетке не стена и игрок там ещё не был

  Таким образом, по аналогии с алгоритмом заливки, игрок, передвигающийся по такому алгоритму, найдет выход, если он есть. Если же выхода из лабиринта нет - игрок обойдет все возможное места и вернется в исходную точку. (В примерах из файла consts.js работа алгоритма лучше всего видна на картах с большим количеством развилок) В моей реализации, вместо рекурсии используется стек (переменная currentPath), в который помещаются данные о сделаных игроком шагах. Данные извлекаются если игрок двигается назад. Эта переменная имеет и другое назначение - в конце выполнения алгоритма в стеке окажется результирующий путь, т.е. такой, будто игрок всегда выбирал правильной направление и не двигался назад. Также, для последующего использования все данные о шагах игрока, в том числе и назад, хранятся в переменной pathLog - полный лог передвижений игрока.
